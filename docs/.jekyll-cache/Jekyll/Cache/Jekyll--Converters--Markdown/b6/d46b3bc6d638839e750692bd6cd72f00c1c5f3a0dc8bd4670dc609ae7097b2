I"lf<p>RDB or Readonly Database is a fast-multi database access data reader and binder,  which let the developer to access multiple database connections at same time and query them to read data very fast then cast result to structured data.</p>

<p>** Note: RDB is not an ORM. RDB is used for api systems to make reusable raw queries and bind http request to query and cast result to struct without to much overhead **</p>

<p>Example:</p>

<p>1- Create connection and add to rdp pool for later use:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rdb</span><span class="o">.</span><span class="n">Register</span><span class="p">()</span>
<span class="n">err</span> <span class="o">:=</span> <span class="n">rdb</span><span class="o">.</span><span class="n">CreateConnection</span><span class="p">(</span><span class="s">"localhost"</span><span class="p">,</span> <span class="s">"mysql"</span><span class="p">,</span> <span class="s">"root:password@localhost/mydb?charset=utf8&amp;parseTime=True"</span><span class="p">)</span>
<span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
	<span class="n">log</span><span class="o">.</span><span class="n">Fatal</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>2- Access db object:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">db</span> <span class="o">=</span> <span class="n">rdb</span><span class="o">.</span><span class="n">GetDBO</span><span class="p">(</span><span class="s">"localhost"</span><span class="p">)</span>
<span class="k">if</span> <span class="n">db</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
    <span class="n">log</span><span class="o">.</span><span class="n">Fatal</span><span class="p">(</span><span class="s">"Null db"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>3- Define Reusable Query, http parser and struct:</p>

<p>for query and structure refer to 
[[jackskj/carta|https://github.com/jackskj/carta]]
 and for data validation refer to [[go-playground/validator|https://github.com/go-playground/validator]]</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">query</span> <span class="o">:=</span> <span class="n">db</span><span class="o">.</span><span class="n">Query</span><span class="p">(</span><span class="s">`
SELECT
       id          as  blog_id,
       title       as  blog_title,
       P.id        as  posts_id,         
       P.name      as  posts_name,
       A.id        as  author_id,      
       A.username  as  author_username
FROM blog
       left outer join author A    on  blog.author_id = A.id
       left outer join post P      on  blog.id = P.blog_id
WHERE blog.id_category = ?
`</span><span class="p">)</span>

<span class="k">type</span> <span class="n">Blog</span> <span class="k">struct</span> <span class="p">{</span>
        <span class="n">Id</span>     <span class="kt">int</span>    <span class="s">`db:"blog_id"`</span>
        <span class="n">Title</span>  <span class="kt">string</span> <span class="s">`db:"blog_title"`</span>
        <span class="n">Posts</span>  <span class="p">[]</span><span class="n">Post</span>
        <span class="n">Author</span> <span class="n">Author</span>
<span class="p">}</span>
<span class="k">type</span> <span class="n">Post</span> <span class="k">struct</span> <span class="p">{</span>
        <span class="n">Id</span>   <span class="kt">int</span>    <span class="s">`db:"posts_id"`</span>
        <span class="n">Name</span> <span class="kt">string</span> <span class="s">`db:"posts_name"`</span>
<span class="p">}</span>
<span class="k">type</span> <span class="n">Author</span> <span class="k">struct</span> <span class="p">{</span>
        <span class="n">Id</span>       <span class="kt">int</span>    <span class="s">`db:"author_id"`</span>
        <span class="n">Username</span> <span class="kt">string</span> <span class="s">`db:"author_username"`</span>
<span class="p">}</span>

<span class="c">//optional: use http parser to auto acquire params from http call </span>
<span class="n">parser</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">rdb</span><span class="o">.</span><span class="n">Parser</span><span class="p">{</span>
	<span class="n">Params</span><span class="o">:</span> <span class="p">[]</span><span class="n">rdb</span><span class="o">.</span><span class="n">Param</span><span class="p">{</span>
                <span class="c">// { parameter name , parameter source (URL,Get,Post,Header,Any) , validator based on https://github.com/go-playground/validator }</span>
		<span class="p">{</span><span class="s">"id"</span><span class="p">,</span> <span class="n">rdb</span><span class="o">.</span><span class="n">URL</span><span class="p">,</span> <span class="s">"numeric"</span><span class="p">},</span>
	<span class="p">},</span>
<span class="p">}</span>

<span class="n">query</span><span class="o">.</span><span class="n">SetParser</span><span class="p">(</span><span class="n">parser</span><span class="p">)</span>
</code></pre></div></div>

<p>4- Manipulating parsed params if needed:</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">parser</span><span class="o">.</span><span class="n">Processor</span> <span class="o">=</span> <span class="k">func</span><span class="p">(</span><span class="n">params</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="kt">string</span> <span class="p">{</span>
	<span class="n">params</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">strconv</span><span class="o">.</span><span class="n">Itoa</span><span class="p">(</span> <span class="n">lib</span><span class="o">.</span><span class="n">ParseSafeInt</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="m">0</span><span class="p">])</span> <span class="o">+</span> <span class="m">1</span> <span class="p">)</span> <span class="c">// add 1 to first arg</span>
	<span class="k">return</span> <span class="n">params</span>
<span class="p">}</span>
</code></pre></div></div>

<p>5- Create API:</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">//with parser</span>
<span class="n">evo</span><span class="o">.</span><span class="n">Get</span><span class="p">(</span><span class="s">"/api/blog/:id"</span><span class="p">,</span> <span class="k">func</span><span class="p">(</span><span class="n">request</span> <span class="o">*</span><span class="n">evo</span><span class="o">.</span><span class="n">Request</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">posts</span> <span class="o">:=</span> <span class="p">[]</span><span class="n">Blog</span><span class="p">{}</span>
	<span class="n">err</span> <span class="o">:=</span> <span class="n">query</span><span class="o">.</span><span class="n">All</span><span class="p">(</span><span class="o">&amp;</span><span class="n">posts</span><span class="p">,</span> <span class="n">request</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="n">log</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="n">request</span><span class="o">.</span><span class="n">WriteResponse</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="p">})</span>

<span class="c">// without http parser</span>
<span class="n">evo</span><span class="o">.</span><span class="n">Get</span><span class="p">(</span><span class="s">"/api/blog/:id"</span><span class="p">,</span> <span class="k">func</span><span class="p">(</span><span class="n">request</span> <span class="o">*</span><span class="n">evo</span><span class="o">.</span><span class="n">Request</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">posts</span> <span class="o">:=</span> <span class="p">[]</span><span class="n">Blog</span><span class="p">{}</span>
	<span class="n">err</span> <span class="o">:=</span> <span class="n">query</span><span class="o">.</span><span class="n">All</span><span class="p">(</span><span class="o">&amp;</span><span class="n">posts</span><span class="p">,</span> <span class="n">request</span><span class="o">.</span><span class="n">Param</span><span class="p">(</span><span class="s">"id"</span><span class="p">))</span>
	<span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="n">log</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="n">request</span><span class="o">.</span><span class="n">WriteResponse</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="p">})</span>
</code></pre></div></div>

<p>RDB will take argument, generate the sql and query to db then map the SQL rows while keeping track of those relationships.</p>

<p>Results:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rows:
blog_id | blog_title | posts_id | posts_name | author_id | author_username
1       | Foo        | 1        | Bar        | 1         | John
1       | Foo        | 2        | Baz        | 1         | John
2       | Egg        | 3        | Beacon     | 2         | Ed

blogs:
[{
	"blog_id": 1,
	"blog_title": "Foo",
	"author": {
		"author_id": 1,
		"author_username": "John"
	},
	"posts": [{
			"post_id": 1,
			"posts_name": "Bar"
		}, {
			"post_id": 2,
			"posts_name": "Baz"
		}]
}, {
	"blog_id": 2,
	"blog_title": "Egg",
	"author": {
		"author_id": 2,
		"author_username": "Ed"
	},
	"posts": [{
			"post_id": 3,
			"posts_name": "Beacon"
		}]
}]
</code></pre></div></div>

<p><strong>Column and Field Names</strong></p>

<p>RDB will match your SQL columns with corresponding fields. You can use a “db” tag to represent a specific column name.
Example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type Blog struct {
	// When tag is not used, the snake case of the fiels is used
	BlogId int // expected column name : "blog_id"

	// When tag is specified, it takes priority
	Abc string `db:"blog_title"` // expected column name: "blog_title"

	// If you define multiple fiels with the same struct,
	// you can use a tag to identify a column prefix 
	// (with underscore concatination)

	// possible column names:  "writer_author_id", "author_id"
	Writer Author `db: "writer"`
        
	// possible column names: "rewiewer_author_id", "author_id",
	Reviewer Author `db: "reviewer"`
}

type Author struct {
	AuthorId int `db:"author_id"`
}
</code></pre></div></div>

<p><strong>Data Types and Relationships</strong></p>

<p>Any primative types, time.Time, protobuf Timestamp, and sql.NullX can be loaded.
These types are one-to-one mapped with your SQL columns</p>

<p>To define more complex SQL relationships use slices and structs as in example below:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type Blog struct {
	BlogId int  // Will map directly with "blog_id" column 

	// If your SQL data can be "null", use pointers or sql.NullX
	AuthorId  *int
	CreatedOn *timestamp.Timestamp // protobuf timestamp
	UpdatedOn *time.Time
	SonsorId  sql.NullInt64

	// To define has-one relationship, use nested structs 
	// or pointer to a struct
	Author *Author

	// To define has-many relationship, use slices
	// options include: *[]*Post, []*Post, *[]Post, []Post
	Posts []*Post 

	// If your has-many relationship corresponds to one column,
	// you can use a slice of a settable type
	TagIds     []int           `db:"tag_id"`
	CommentIds []sql.NullInt64 `db:"comment_id"`
}
</code></pre></div></div>

<p><strong>Important Note</strong></p>

<p>RDB removes any duplicate rows. This is a side effect of the data mapping as it is unclear which object to instantiate if the same data arrives more than once. If this is not a desired outcome, you should include a uniquely identifiable columns in your query and the corresponding fields in your structs.</p>

<p>To prevent relatively expensive reflect operations, RDB caches the structure of your struct using the column names of your query response as well as the type of your struct.</p>

<p>RDB or Readonly Database is a fast-multi database access data reader and binder,  which let the developer to access multiple database connections at same time and query them to read data very fast then cast result to structured data.</p>

<p>** Note: RDB is not an ORM. RDB is used for api systems to make reusable raw queries and bind http request to query and cast result to struct without to much overhead **</p>

<p>Example:</p>

<p>1- Create connection and add to rdp pool for later use:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rdb</span><span class="o">.</span><span class="n">Register</span><span class="p">()</span>
<span class="n">err</span> <span class="o">:=</span> <span class="n">rdb</span><span class="o">.</span><span class="n">CreateConnection</span><span class="p">(</span><span class="s">"localhost"</span><span class="p">,</span> <span class="s">"mysql"</span><span class="p">,</span> <span class="s">"root:password@localhost/mydb?charset=utf8&amp;parseTime=True"</span><span class="p">)</span>
<span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
	<span class="n">log</span><span class="o">.</span><span class="n">Fatal</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>2- Access db object:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">db</span> <span class="o">=</span> <span class="n">rdb</span><span class="o">.</span><span class="n">GetDBO</span><span class="p">(</span><span class="s">"localhost"</span><span class="p">)</span>
<span class="k">if</span> <span class="n">db</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
    <span class="n">log</span><span class="o">.</span><span class="n">Fatal</span><span class="p">(</span><span class="s">"Null db"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>3- Define Reusable Query, http parser and struct:</p>

<p>for query and structure refer to 
[[jackskj/carta|https://github.com/jackskj/carta]]
 and for data validation refer to [[go-playground/validator|https://github.com/go-playground/validator]]</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">query</span> <span class="o">:=</span> <span class="n">db</span><span class="o">.</span><span class="n">Query</span><span class="p">(</span><span class="s">`
SELECT
       id          as  blog_id,
       title       as  blog_title,
       P.id        as  posts_id,         
       P.name      as  posts_name,
       A.id        as  author_id,      
       A.username  as  author_username
FROM blog
       left outer join author A    on  blog.author_id = A.id
       left outer join post P      on  blog.id = P.blog_id
WHERE blog.id_category = ?
`</span><span class="p">)</span>

<span class="k">type</span> <span class="n">Blog</span> <span class="k">struct</span> <span class="p">{</span>
        <span class="n">Id</span>     <span class="kt">int</span>    <span class="s">`db:"blog_id"`</span>
        <span class="n">Title</span>  <span class="kt">string</span> <span class="s">`db:"blog_title"`</span>
        <span class="n">Posts</span>  <span class="p">[]</span><span class="n">Post</span>
        <span class="n">Author</span> <span class="n">Author</span>
<span class="p">}</span>
<span class="k">type</span> <span class="n">Post</span> <span class="k">struct</span> <span class="p">{</span>
        <span class="n">Id</span>   <span class="kt">int</span>    <span class="s">`db:"posts_id"`</span>
        <span class="n">Name</span> <span class="kt">string</span> <span class="s">`db:"posts_name"`</span>
<span class="p">}</span>
<span class="k">type</span> <span class="n">Author</span> <span class="k">struct</span> <span class="p">{</span>
        <span class="n">Id</span>       <span class="kt">int</span>    <span class="s">`db:"author_id"`</span>
        <span class="n">Username</span> <span class="kt">string</span> <span class="s">`db:"author_username"`</span>
<span class="p">}</span>

<span class="c">//optional: use http parser to auto acquire params from http call </span>
<span class="n">parser</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">rdb</span><span class="o">.</span><span class="n">Parser</span><span class="p">{</span>
	<span class="n">Params</span><span class="o">:</span> <span class="p">[]</span><span class="n">rdb</span><span class="o">.</span><span class="n">Param</span><span class="p">{</span>
                <span class="c">// { parameter name , parameter source (URL,Get,Post,Header,Any) , validator based on https://github.com/go-playground/validator }</span>
		<span class="p">{</span><span class="s">"id"</span><span class="p">,</span> <span class="n">rdb</span><span class="o">.</span><span class="n">URL</span><span class="p">,</span> <span class="s">"numeric"</span><span class="p">},</span>
	<span class="p">},</span>
<span class="p">}</span>

<span class="n">query</span><span class="o">.</span><span class="n">SetParser</span><span class="p">(</span><span class="n">parser</span><span class="p">)</span>
</code></pre></div></div>

<p>4- Manipulating parsed params if needed:</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">parser</span><span class="o">.</span><span class="n">Processor</span> <span class="o">=</span> <span class="k">func</span><span class="p">(</span><span class="n">params</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="kt">string</span> <span class="p">{</span>
	<span class="n">params</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">strconv</span><span class="o">.</span><span class="n">Itoa</span><span class="p">(</span> <span class="n">lib</span><span class="o">.</span><span class="n">ParseSafeInt</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="m">0</span><span class="p">])</span> <span class="o">+</span> <span class="m">1</span> <span class="p">)</span> <span class="c">// add 1 to first arg</span>
	<span class="k">return</span> <span class="n">params</span>
<span class="p">}</span>
</code></pre></div></div>

<p>5- Create API:</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">//with parser</span>
<span class="n">evo</span><span class="o">.</span><span class="n">Get</span><span class="p">(</span><span class="s">"/api/blog/:id"</span><span class="p">,</span> <span class="k">func</span><span class="p">(</span><span class="n">request</span> <span class="o">*</span><span class="n">evo</span><span class="o">.</span><span class="n">Request</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">posts</span> <span class="o">:=</span> <span class="p">[]</span><span class="n">Blog</span><span class="p">{}</span>
	<span class="n">err</span> <span class="o">:=</span> <span class="n">query</span><span class="o">.</span><span class="n">All</span><span class="p">(</span><span class="o">&amp;</span><span class="n">posts</span><span class="p">,</span> <span class="n">request</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="n">log</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="n">request</span><span class="o">.</span><span class="n">WriteResponse</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="p">})</span>

<span class="c">// without http parser</span>
<span class="n">evo</span><span class="o">.</span><span class="n">Get</span><span class="p">(</span><span class="s">"/api/blog/:id"</span><span class="p">,</span> <span class="k">func</span><span class="p">(</span><span class="n">request</span> <span class="o">*</span><span class="n">evo</span><span class="o">.</span><span class="n">Request</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">posts</span> <span class="o">:=</span> <span class="p">[]</span><span class="n">Blog</span><span class="p">{}</span>
	<span class="n">err</span> <span class="o">:=</span> <span class="n">query</span><span class="o">.</span><span class="n">All</span><span class="p">(</span><span class="o">&amp;</span><span class="n">posts</span><span class="p">,</span> <span class="n">request</span><span class="o">.</span><span class="n">Param</span><span class="p">(</span><span class="s">"id"</span><span class="p">))</span>
	<span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="n">log</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="n">request</span><span class="o">.</span><span class="n">WriteResponse</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="p">})</span>
</code></pre></div></div>

<p>RDB will take argument, generate the sql and query to db then map the SQL rows while keeping track of those relationships.</p>

<p>Results:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rows:
blog_id | blog_title | posts_id | posts_name | author_id | author_username
1       | Foo        | 1        | Bar        | 1         | John
1       | Foo        | 2        | Baz        | 1         | John
2       | Egg        | 3        | Beacon     | 2         | Ed

blogs:
[{
	"blog_id": 1,
	"blog_title": "Foo",
	"author": {
		"author_id": 1,
		"author_username": "John"
	},
	"posts": [{
			"post_id": 1,
			"posts_name": "Bar"
		}, {
			"post_id": 2,
			"posts_name": "Baz"
		}]
}, {
	"blog_id": 2,
	"blog_title": "Egg",
	"author": {
		"author_id": 2,
		"author_username": "Ed"
	},
	"posts": [{
			"post_id": 3,
			"posts_name": "Beacon"
		}]
}]
</code></pre></div></div>

<p><strong>Column and Field Names</strong></p>

<p>RDB will match your SQL columns with corresponding fields. You can use a “db” tag to represent a specific column name.
Example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type Blog struct {
	// When tag is not used, the snake case of the fiels is used
	BlogId int // expected column name : "blog_id"

	// When tag is specified, it takes priority
	Abc string `db:"blog_title"` // expected column name: "blog_title"

	// If you define multiple fiels with the same struct,
	// you can use a tag to identify a column prefix 
	// (with underscore concatination)

	// possible column names:  "writer_author_id", "author_id"
	Writer Author `db: "writer"`
        
	// possible column names: "rewiewer_author_id", "author_id",
	Reviewer Author `db: "reviewer"`
}

type Author struct {
	AuthorId int `db:"author_id"`
}
</code></pre></div></div>

<p><strong>Data Types and Relationships</strong></p>

<p>Any primative types, time.Time, protobuf Timestamp, and sql.NullX can be loaded.
These types are one-to-one mapped with your SQL columns</p>

<p>To define more complex SQL relationships use slices and structs as in example below:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type Blog struct {
	BlogId int  // Will map directly with "blog_id" column 

	// If your SQL data can be "null", use pointers or sql.NullX
	AuthorId  *int
	CreatedOn *timestamp.Timestamp // protobuf timestamp
	UpdatedOn *time.Time
	SonsorId  sql.NullInt64

	// To define has-one relationship, use nested structs 
	// or pointer to a struct
	Author *Author

	// To define has-many relationship, use slices
	// options include: *[]*Post, []*Post, *[]Post, []Post
	Posts []*Post 

	// If your has-many relationship corresponds to one column,
	// you can use a slice of a settable type
	TagIds     []int           `db:"tag_id"`
	CommentIds []sql.NullInt64 `db:"comment_id"`
}
</code></pre></div></div>

<p><strong>Important Note</strong></p>

<p>RDB removes any duplicate rows. This is a side effect of the data mapping as it is unclear which object to instantiate if the same data arrives more than once. If this is not a desired outcome, you should include a uniquely identifiable columns in your query and the corresponding fields in your structs.</p>

<p>To prevent relatively expensive reflect operations, RDB caches the structure of your struct using the column names of your query response as well as the type of your struct.</p>

:ET