{"0": {
    "doc": "Configuration",
    "title": "Configuration",
    "content": "EVO is able to parse yml files as config. By default EVO tries to reach config.yml at working directory of the executable app. If EVO was not be able to find config.yml then it tries: . For Linux: . /home/username /var /etc / . And for Windows: . %USERNAME% %LOCALAPPDATA% %HOMEPATH% %APPDATA% %ALLUSERSPROFILE% . You may pass different path or file name for config.yml by passig -c arg to executable app. ",
    "url": "http://localhost:4000/docs/configuration.html",
    "relUrl": "/docs/configuration.html"
  },"1": {
    "doc": "Configuration",
    "title": "Configuration structure",
    "content": "# App configurations app: name: \"Sample App\" #Application Name language: en-GB #Application Lang static: ./httpdocs #Static files path session-age: 60 #Login session age #0 to 4 strong-pass-level: 0 #Password difficulty jwt: secret: \"a.random.public.key\" #JWT Secret issuer: \"evo\" #JWT Issuer audience: [\"*\"] #JWT Audience age: 24h #JWT Expiration Period subject: \"Evo App\" #JWT Subject # Server configurations server: host: \"0.0.0.0\" #Host port: \"80\" #Port https: false #Use https? cert: cert.pem #ssl cert key: key.pem #ssl key name: \"evo\" #Server name exposed in header strict-routing: false #Care about slashes at the end of urls? case-sensitive: false #Care about uppercase/lowercase urls? max-upload-size: 5M #Max Upload Size request-id: true #Set uinque id for each request in header debug: true #Show debug data recover: false #Recover on panics # Database credentials database: enabled: true #Use database? type: \"sqlite\" #Kind of database: mssql,mysql,postgres,sqlite server: \"\" #Server address database: \"database.sqlite3\" #Database name user: \"admin\" #Database username pass: \"super-pedro-1980\" #Database password cache: true #Cache results? cache-size: 1000 #Cache size debug: false #Debug database? ssl-mode: \"disable\" #Database over ssl max-open-connections: 100 #Max db concurrent connections max-idle-connections: 10 #Max db idle connections connection-max-lifetime: 1h #Renew connection after duration #Log to file log: writefile: true #Write Log to file size: 5 #Log size in mb age: 7 #Log age in days level: debug #Log level to write on file path: ./logs #Log path #Tweaks tweaks: ballast: true #Use ballast? https://blog.twitch.tv/en/2019/04/10/go-memory-ballast-how-i-learnt-to-stop-worrying-and-love-the-heap-26c2462549a2/ ballast-size: 100mb #ballast processors: 0 #number of processors to occupy prefork: false #use prefork https://httpd.apache.org/docs/2.4/mod/prefork.html #Cross Origin Resource Sharing cors: enabled: true #enable cors? allowed-origins: [\"*\"] #cors trusted origins allowed-methods: [\"GET\",\"POST\",\"HEAD\",\"OPTION\",\"PUT\",\"PATCH\",\"DELETE\"] #cors enabled methods allowed-credentials: true #cors enable credentials? allowed-headers: [\"*\"] #cors enabled headers max-age: 0 #max preflight age #Rate Limiter ratelimit: enabled: false #enable rate limiter? duration: 10 #rate limiter duration to keep data requests: 10 #number of requests in duration . ",
    "url": "http://localhost:4000/docs/configuration.html#configuration-structure",
    "relUrl": "/docs/configuration.html#configuration-structure"
  },"2": {
    "doc": "Configuration",
    "title": "Custom configuration for apps",
    "content": "You may add custom configuration to the apps in to ways: Embed configuration in default app config: . type Custom struct { Array []string `yaml:\"array\"` } cfg := Custom{} //load custom key from app config evo.ParseConfig(\"\", \"custom\", &amp;cfg) log.Print(cfg) . Read configuration from custom config file: . //load custom key from custom file evo.ParseConfig(\"custom.yml\", \"custom\", &amp;cfg) log.Print(cfg) . ",
    "url": "http://localhost:4000/docs/configuration.html#custom-configuration-for-apps",
    "relUrl": "/docs/configuration.html#custom-configuration-for-apps"
  },"3": {
    "doc": "Markdown kitchen sink",
    "title": "Markdown kitchen sink",
    "content": " ",
    "url": "http://localhost:4000/docs/index-test.html",
    "relUrl": "/docs/index-test.html"
  },"4": {
    "doc": "Home",
    "title": "This wiki is primarily aimed at engineers building or making contributions to EVO.",
    "content": "If you are new to EVO, then you will find more general information on the EVO project, including tutorials and samples. If you want to know what we’re likely to do in the future, our roadmap may be of interest. If you intend to contribute to EVO, welcome! You are encouraged to start with our contributor guide, which helps onboard new team members. It points to the most relevant pages on this wiki. ",
    "url": "http://localhost:4000/#this-wiki-is-primarily-aimed-at-engineers-building-or-making-contributions-to-evo",
    "relUrl": "/#this-wiki-is-primarily-aimed-at-engineers-building-or-making-contributions-to-evo"
  },"5": {
    "doc": "Home",
    "title": "Index of notable sections",
    "content": "Why EVO . Architecture . Simple Example . Learn By Example . Apps . ",
    "url": "http://localhost:4000/#index-of-notable-sections",
    "relUrl": "/#index-of-notable-sections"
  },"6": {
    "doc": "Home",
    "title": "Home",
    "content": " ",
    "url": "http://localhost:4000/",
    "relUrl": "/"
  },"7": {
    "doc": "Readonly Database",
    "title": "Readonly Database",
    "content": "RDB or Readonly Database is a fast-multi database access data reader and binder, which let the developer to access multiple database connections at same time and query them to read data very fast then cast result to structured data. ** Note: RDB is not an ORM. RDB is used for api systems to make reusable raw queries and bind http request to query and cast result to struct without to much overhead ** . Example: . 1- Create connection and add to rdp pool for later use: . rdb.Register() err := rdb.CreateConnection(\"localhost\", \"mysql\", \"root:password@localhost/mydb?charset=utf8&amp;parseTime=True\") if err != nil { log.Fatal(err) } . 2- Access db object: . var db = rdb.GetDBO(\"localhost\") if db == nil { log.Fatal(\"Null db\") } . 3- Define Reusable Query, http parser and struct: . for query and structure refer to [[jackskj/carta|https://github.com/jackskj/carta]] and for data validation refer to [[go-playground/validator|https://github.com/go-playground/validator]] . query := db.Query(` SELECT id as blog_id, title as blog_title, P.id as posts_id, P.name as posts_name, A.id as author_id, A.username as author_username FROM blog left outer join author A on blog.author_id = A.id left outer join post P on blog.id = P.blog_id WHERE blog.id_category = ? `) type Blog struct { Id int `db:\"blog_id\"` Title string `db:\"blog_title\"` Posts []Post Author Author } type Post struct { Id int `db:\"posts_id\"` Name string `db:\"posts_name\"` } type Author struct { Id int `db:\"author_id\"` Username string `db:\"author_username\"` } //optional: use http parser to auto acquire params from http call parser := &amp;rdb.Parser{ Params: []rdb.Param{ // { parameter name , parameter source (URL,Get,Post,Header,Any) , validator based on https://github.com/go-playground/validator } {\"id\", rdb.URL, \"numeric\"}, }, } query.SetParser(parser) . 4- Manipulating parsed params if needed: . parser.Processor = func(params []string) []string { params[0] = strconv.Itoa( lib.ParseSafeInt(params[0]) + 1 ) // add 1 to first arg return params } . 5- Create API: . //with parser evo.Get(\"/api/blog/:id\", func(request *evo.Request) { posts := []Blog{} err := query.All(&amp;posts, request) if err != nil { log.Error(err) } request.WriteResponse(data) }) // without http parser evo.Get(\"/api/blog/:id\", func(request *evo.Request) { posts := []Blog{} err := query.All(&amp;posts, request.Param(\"id\")) if err != nil { log.Error(err) } request.WriteResponse(data) }) . RDB will take argument, generate the sql and query to db then map the SQL rows while keeping track of those relationships. Results: . rows: blog_id | blog_title | posts_id | posts_name | author_id | author_username 1 | Foo | 1 | Bar | 1 | John 1 | Foo | 2 | Baz | 1 | John 2 | Egg | 3 | Beacon | 2 | Ed blogs: [{ \"blog_id\": 1, \"blog_title\": \"Foo\", \"author\": { \"author_id\": 1, \"author_username\": \"John\" }, \"posts\": [{ \"post_id\": 1, \"posts_name\": \"Bar\" }, { \"post_id\": 2, \"posts_name\": \"Baz\" }] }, { \"blog_id\": 2, \"blog_title\": \"Egg\", \"author\": { \"author_id\": 2, \"author_username\": \"Ed\" }, \"posts\": [{ \"post_id\": 3, \"posts_name\": \"Beacon\" }] }] . Column and Field Names . RDB will match your SQL columns with corresponding fields. You can use a “db” tag to represent a specific column name. Example: . type Blog struct { // When tag is not used, the snake case of the fiels is used BlogId int // expected column name : \"blog_id\" // When tag is specified, it takes priority Abc string `db:\"blog_title\"` // expected column name: \"blog_title\" // If you define multiple fiels with the same struct, // you can use a tag to identify a column prefix // (with underscore concatination) // possible column names: \"writer_author_id\", \"author_id\" Writer Author `db: \"writer\"` // possible column names: \"rewiewer_author_id\", \"author_id\", Reviewer Author `db: \"reviewer\"` } type Author struct { AuthorId int `db:\"author_id\"` } . Data Types and Relationships . Any primative types, time.Time, protobuf Timestamp, and sql.NullX can be loaded. These types are one-to-one mapped with your SQL columns . To define more complex SQL relationships use slices and structs as in example below: . type Blog struct { BlogId int // Will map directly with \"blog_id\" column // If your SQL data can be \"null\", use pointers or sql.NullX AuthorId *int CreatedOn *timestamp.Timestamp // protobuf timestamp UpdatedOn *time.Time SonsorId sql.NullInt64 // To define has-one relationship, use nested structs // or pointer to a struct Author *Author // To define has-many relationship, use slices // options include: *[]*Post, []*Post, *[]Post, []Post Posts []*Post // If your has-many relationship corresponds to one column, // you can use a slice of a settable type TagIds []int `db:\"tag_id\"` CommentIds []sql.NullInt64 `db:\"comment_id\"` } . Important Note . RDB removes any duplicate rows. This is a side effect of the data mapping as it is unclear which object to instantiate if the same data arrives more than once. If this is not a desired outcome, you should include a uniquely identifiable columns in your query and the corresponding fields in your structs. To prevent relatively expensive reflect operations, RDB caches the structure of your struct using the column names of your query response as well as the type of your struct. RDB or Readonly Database is a fast-multi database access data reader and binder, which let the developer to access multiple database connections at same time and query them to read data very fast then cast result to structured data. ** Note: RDB is not an ORM. RDB is used for api systems to make reusable raw queries and bind http request to query and cast result to struct without to much overhead ** . Example: . 1- Create connection and add to rdp pool for later use: . rdb.Register() err := rdb.CreateConnection(\"localhost\", \"mysql\", \"root:password@localhost/mydb?charset=utf8&amp;parseTime=True\") if err != nil { log.Fatal(err) } . 2- Access db object: . var db = rdb.GetDBO(\"localhost\") if db == nil { log.Fatal(\"Null db\") } . 3- Define Reusable Query, http parser and struct: . for query and structure refer to [[jackskj/carta|https://github.com/jackskj/carta]] and for data validation refer to [[go-playground/validator|https://github.com/go-playground/validator]] . query := db.Query(` SELECT id as blog_id, title as blog_title, P.id as posts_id, P.name as posts_name, A.id as author_id, A.username as author_username FROM blog left outer join author A on blog.author_id = A.id left outer join post P on blog.id = P.blog_id WHERE blog.id_category = ? `) type Blog struct { Id int `db:\"blog_id\"` Title string `db:\"blog_title\"` Posts []Post Author Author } type Post struct { Id int `db:\"posts_id\"` Name string `db:\"posts_name\"` } type Author struct { Id int `db:\"author_id\"` Username string `db:\"author_username\"` } //optional: use http parser to auto acquire params from http call parser := &amp;rdb.Parser{ Params: []rdb.Param{ // { parameter name , parameter source (URL,Get,Post,Header,Any) , validator based on https://github.com/go-playground/validator } {\"id\", rdb.URL, \"numeric\"}, }, } query.SetParser(parser) . 4- Manipulating parsed params if needed: . parser.Processor = func(params []string) []string { params[0] = strconv.Itoa( lib.ParseSafeInt(params[0]) + 1 ) // add 1 to first arg return params } . 5- Create API: . //with parser evo.Get(\"/api/blog/:id\", func(request *evo.Request) { posts := []Blog{} err := query.All(&amp;posts, request) if err != nil { log.Error(err) } request.WriteResponse(data) }) // without http parser evo.Get(\"/api/blog/:id\", func(request *evo.Request) { posts := []Blog{} err := query.All(&amp;posts, request.Param(\"id\")) if err != nil { log.Error(err) } request.WriteResponse(data) }) . RDB will take argument, generate the sql and query to db then map the SQL rows while keeping track of those relationships. Results: . rows: blog_id | blog_title | posts_id | posts_name | author_id | author_username 1 | Foo | 1 | Bar | 1 | John 1 | Foo | 2 | Baz | 1 | John 2 | Egg | 3 | Beacon | 2 | Ed blogs: [{ \"blog_id\": 1, \"blog_title\": \"Foo\", \"author\": { \"author_id\": 1, \"author_username\": \"John\" }, \"posts\": [{ \"post_id\": 1, \"posts_name\": \"Bar\" }, { \"post_id\": 2, \"posts_name\": \"Baz\" }] }, { \"blog_id\": 2, \"blog_title\": \"Egg\", \"author\": { \"author_id\": 2, \"author_username\": \"Ed\" }, \"posts\": [{ \"post_id\": 3, \"posts_name\": \"Beacon\" }] }] . Column and Field Names . RDB will match your SQL columns with corresponding fields. You can use a “db” tag to represent a specific column name. Example: . type Blog struct { // When tag is not used, the snake case of the fiels is used BlogId int // expected column name : \"blog_id\" // When tag is specified, it takes priority Abc string `db:\"blog_title\"` // expected column name: \"blog_title\" // If you define multiple fiels with the same struct, // you can use a tag to identify a column prefix // (with underscore concatination) // possible column names: \"writer_author_id\", \"author_id\" Writer Author `db: \"writer\"` // possible column names: \"rewiewer_author_id\", \"author_id\", Reviewer Author `db: \"reviewer\"` } type Author struct { AuthorId int `db:\"author_id\"` } . Data Types and Relationships . Any primative types, time.Time, protobuf Timestamp, and sql.NullX can be loaded. These types are one-to-one mapped with your SQL columns . To define more complex SQL relationships use slices and structs as in example below: . type Blog struct { BlogId int // Will map directly with \"blog_id\" column // If your SQL data can be \"null\", use pointers or sql.NullX AuthorId *int CreatedOn *timestamp.Timestamp // protobuf timestamp UpdatedOn *time.Time SonsorId sql.NullInt64 // To define has-one relationship, use nested structs // or pointer to a struct Author *Author // To define has-many relationship, use slices // options include: *[]*Post, []*Post, *[]Post, []Post Posts []*Post // If your has-many relationship corresponds to one column, // you can use a slice of a settable type TagIds []int `db:\"tag_id\"` CommentIds []sql.NullInt64 `db:\"comment_id\"` } . Important Note . RDB removes any duplicate rows. This is a side effect of the data mapping as it is unclear which object to instantiate if the same data arrives more than once. If this is not a desired outcome, you should include a uniquely identifiable columns in your query and the corresponding fields in your structs. To prevent relatively expensive reflect operations, RDB caches the structure of your struct using the column names of your query response as well as the type of your struct. ",
    "url": "http://localhost:4000/docs/rdb.html",
    "relUrl": "/docs/rdb.html"
  },"8": {
    "doc": "Search",
    "title": "Search",
    "content": " ",
    "url": "http://localhost:4000/docs/search.html",
    "relUrl": "/docs/search.html"
  },"9": {
    "doc": "Search",
    "title": "Table of contents",
    "content": ". | Enable search in configuration . | Search granularity | Search previews | Search tokenizer | Display URL in search results | Display search button | . | Hiding pages from search | Generate search index when used as a gem | . Just the Docs uses lunr.js to add a client-side search interface powered by a JSON index that Jekyll generates. All search results are shown in an auto-complete style interface (there is no search results page). By default, all generated HTML pages are indexed using the following data points: . | Page title | Page content | Page URL | . ",
    "url": "http://localhost:4000/docs/search.html#table-of-contents",
    "relUrl": "/docs/search.html#table-of-contents"
  },"10": {
    "doc": "Search",
    "title": "Enable search in configuration",
    "content": "In your site’s _config.yml, enable search: . # Enable or disable the site search # Supports true (default) or false search_enabled: true . Search granularity . Pages are split into sections that can be searched individually. The sections are defined by the headings on the page. Each section is displayed in a separate search result. # Split pages into sections that can be searched individually # Supports 1 - 6, default: 2 search.heading_level: 2 . Search previews . A search result can contain previews that show where the search words are found in the specific section. # Maximum amount of previews per search result # Default: 3 search.previews: 3 # Maximum amount of words to display before a matched word in the preview # Default: 5 search.preview_words_before: 5 # Maximum amount of words to display after a matched word in the preview # Default: 10 search.preview_words_after: 10 . Search tokenizer . The default is for hyphens to separate tokens in search terms: gem-based is equivalent to gem based, matching either word. To allow search for hyphenated words: . # Set the search token separator # Default: /[\\s\\-/]+/ # Example: enable support for hyphenated search words search.tokenizer_separator: /[\\s/]+/ . Display URL in search results . # Display the relative url in search results # Supports true (default) or false search.rel_url: false . Display search button . The search button displays in the bottom right corner of the screen and triggers the search input when clicked. # Enable or disable the search button that appears in the bottom right corner of every page # Supports true or false (default) search.button: true . ",
    "url": "http://localhost:4000/docs/search.html#enable-search-in-configuration",
    "relUrl": "/docs/search.html#enable-search-in-configuration"
  },"11": {
    "doc": "Search",
    "title": "Hiding pages from search",
    "content": "Sometimes you might have a page that you don’t want to be indexed for the search nor to show up in search results, e.g, a 404 page. To exclude a page from search, add the search_exclude: true parameter to the page’s YAML front matter: . Example . --- layout: default title: Page not found nav_exclude: true search_exclude: true --- . ",
    "url": "http://localhost:4000/docs/search.html#hiding-pages-from-search",
    "relUrl": "/docs/search.html#hiding-pages-from-search"
  },"12": {
    "doc": "Search",
    "title": "Generate search index when used as a gem",
    "content": "If you use Just the Docs as a remote theme, you do not need the following steps. If you use the theme as a gem, you must initialize the search by running this rake command that comes with just-the-docs: . $ bundle exec just-the-docs rake search:init . This command creates the assets/js/zzzz-search-data.json file that Jekyll uses to create your search index. Alternatively, you can create the file manually with this content. ",
    "url": "http://localhost:4000/docs/search.html#generate-search-index-when-used-as-a-gem",
    "relUrl": "/docs/search.html#generate-search-index-when-used-as-a-gem"
  }
}
