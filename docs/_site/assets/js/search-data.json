{"0": {
    "doc": "Config Example",
    "title": "Config examples",
    "content": " ",
    "url": "http://localhost:4000/docs/examples/config_example/#config-examples",
    "relUrl": "/docs/examples/config_example/#config-examples"
  },"1": {
    "doc": "Config Example",
    "title": "Config Example",
    "content": " ",
    "url": "http://localhost:4000/docs/examples/config_example/",
    "relUrl": "/docs/examples/config_example/"
  },"2": {
    "doc": "Configuration",
    "title": "Configuration",
    "content": "EVO is able to parse yml files as config. By default EVO tries to reach config.yml at working directory of the executable app. If EVO was not be able to find config.yml then it tries: . For Linux: . /home/username /var /etc / . And for Windows: . %USERNAME% %LOCALAPPDATA% %HOMEPATH% %APPDATA% %ALLUSERSPROFILE% . You may pass different path or file name for config.yml by passig -c arg to executable app. ",
    "url": "http://localhost:4000/docs/configuration/",
    "relUrl": "/docs/configuration/"
  },"3": {
    "doc": "Configuration",
    "title": "Configuration structure",
    "content": "# App configurations app: name: \"Sample App\" #Application Name language: en-GB #Application Lang static: ./httpdocs #Static files path session-age: 60 #Login session age #0 to 4 strong-pass-level: 0 #Password difficulty jwt: secret: \"a.random.public.key\" #JWT Secret issuer: \"evo\" #JWT Issuer audience: [\"*\"] #JWT Audience age: 24h #JWT Expiration Period subject: \"Evo App\" #JWT Subject # Server configurations server: host: \"0.0.0.0\" #Host port: \"80\" #Port https: false #Use https? cert: cert.pem #ssl cert key: key.pem #ssl key name: \"evo\" #Server name exposed in header strict-routing: false #Care about slashes at the end of urls? case-sensitive: false #Care about uppercase/lowercase urls? max-upload-size: 5M #Max Upload Size request-id: true #Set uinque id for each request in header debug: true #Show debug data recover: false #Recover on panics # Database credentials database: enabled: true #Use database? type: \"sqlite\" #Kind of database: mssql,mysql,postgres,sqlite server: \"\" #Server address database: \"database.sqlite3\" #Database name user: \"admin\" #Database username pass: \"super-pedro-1980\" #Database password cache: true #Cache results? cache-size: 1000 #Cache size debug: false #Debug database? ssl-mode: \"disable\" #Database over ssl max-open-connections: 100 #Max db concurrent connections max-idle-connections: 10 #Max db idle connections connection-max-lifetime: 1h #Renew connection after duration #Log to file log: writefile: true #Write Log to file size: 5 #Log size in mb age: 7 #Log age in days level: debug #Log level to write on file path: ./logs #Log path #Tweaks tweaks: ballast: true #Use ballast? https://blog.twitch.tv/en/2019/04/10/go-memory-ballast-how-i-learnt-to-stop-worrying-and-love-the-heap-26c2462549a2/ ballast-size: 100mb #ballast processors: 0 #number of processors to occupy prefork: false #use prefork https://httpd.apache.org/docs/2.4/mod/prefork.html #Cross Origin Resource Sharing cors: enabled: true #enable cors? allowed-origins: [\"*\"] #cors trusted origins allowed-methods: [\"GET\",\"POST\",\"HEAD\",\"OPTION\",\"PUT\",\"PATCH\",\"DELETE\"] #cors enabled methods allowed-credentials: true #cors enable credentials? allowed-headers: [\"*\"] #cors enabled headers max-age: 0 #max preflight age #Rate Limiter ratelimit: enabled: false #enable rate limiter? duration: 10 #rate limiter duration to keep data requests: 10 #number of requests in duration . ",
    "url": "http://localhost:4000/docs/configuration/#configuration-structure",
    "relUrl": "/docs/configuration/#configuration-structure"
  },"4": {
    "doc": "Configuration",
    "title": "Custom configuration for apps",
    "content": "You may add custom configuration to the apps in to ways: Embed configuration in default app config: . type Custom struct { Array []string `yaml:\"array\"` } cfg := Custom{} //load custom key from app config evo.ParseConfig(\"\", \"custom\", &amp;cfg) log.Print(cfg) . Read configuration from custom config file: . //load custom key from custom file evo.ParseConfig(\"custom.yml\", \"custom\", &amp;cfg) log.Print(cfg) . ",
    "url": "http://localhost:4000/docs/configuration/#custom-configuration-for-apps",
    "relUrl": "/docs/configuration/#custom-configuration-for-apps"
  },"5": {
    "doc": "Examples",
    "title": "Examples",
    "content": " ",
    "url": "http://localhost:4000/docs/examples",
    "relUrl": "/docs/examples"
  },"6": {
    "doc": "Index Test",
    "title": "Index Test",
    "content": " ",
    "url": "http://localhost:4000/docs/index-test/",
    "relUrl": "/docs/index-test/"
  },"7": {
    "doc": "Home",
    "title": "This wiki is primarily aimed at engineers building or making contributions to EVO.",
    "content": "If you are new to EVO, then you will find more general information on the EVO project, including tutorials and samples. If you want to know what we’re likely to do in the future, our roadmap may be of interest. If you intend to contribute to EVO, welcome! You are encouraged to start with our contributor guide, which helps onboard new team members. It points to the most relevant pages on this wiki. ",
    "url": "http://localhost:4000/#this-wiki-is-primarily-aimed-at-engineers-building-or-making-contributions-to-evo",
    "relUrl": "/#this-wiki-is-primarily-aimed-at-engineers-building-or-making-contributions-to-evo"
  },"8": {
    "doc": "Home",
    "title": "Index of notable sections",
    "content": ". | Why EVO | Architecture | Simple Example | Learn By Example | Apps | . ",
    "url": "http://localhost:4000/#index-of-notable-sections",
    "relUrl": "/#index-of-notable-sections"
  },"9": {
    "doc": "Home",
    "title": "Home",
    "content": " ",
    "url": "http://localhost:4000/",
    "relUrl": "/"
  },"10": {
    "doc": "Readonly Database",
    "title": "Readonly Database",
    "content": "RDB or Readonly Database is a fast-multi database access data reader and binder, which let the developer to access multiple database connections at same time and query them to read data very fast then cast result to structured data. ** Note: RDB is not an ORM. RDB is used for api systems to make reusable raw queries and bind http request to query and cast result to struct without to much overhead ** . Example: . 1- Create connection and add to rdp pool for later use: . rdb.Register() err := rdb.CreateConnection(\"localhost\", \"mysql\", \"root:password@localhost/mydb?charset=utf8&amp;parseTime=True\") if err != nil { log.Fatal(err) } . 2- Access db object: . var db = rdb.GetDBO(\"localhost\") if db == nil { log.Fatal(\"Null db\") } . 3- Define Reusable Query, http parser and struct: . for query and structure refer to [[jackskj/carta|https://github.com/jackskj/carta]] and for data validation refer to [[go-playground/validator|https://github.com/go-playground/validator]] . query := db.Query(` SELECT id as blog_id, title as blog_title, P.id as posts_id, P.name as posts_name, A.id as author_id, A.username as author_username FROM blog left outer join author A on blog.author_id = A.id left outer join post P on blog.id = P.blog_id WHERE blog.id_category = ? `) type Blog struct { Id int `db:\"blog_id\"` Title string `db:\"blog_title\"` Posts []Post Author Author } type Post struct { Id int `db:\"posts_id\"` Name string `db:\"posts_name\"` } type Author struct { Id int `db:\"author_id\"` Username string `db:\"author_username\"` } //optional: use http parser to auto acquire params from http call parser := &amp;rdb.Parser{ Params: []rdb.Param{ // { parameter name , parameter source (URL,Get,Post,Header,Any) , validator based on https://github.com/go-playground/validator } {\"id\", rdb.URL, \"numeric\"}, }, } query.SetParser(parser) . 4- Manipulating parsed params if needed: . parser.Processor = func(params []string) []string { params[0] = strconv.Itoa( lib.ParseSafeInt(params[0]) + 1 ) // add 1 to first arg return params } . 5- Create API: . //with parser evo.Get(\"/api/blog/:id\", func(request *evo.Request) { posts := []Blog{} err := query.All(&amp;posts, request) if err != nil { log.Error(err) } request.WriteResponse(data) }) // without http parser evo.Get(\"/api/blog/:id\", func(request *evo.Request) { posts := []Blog{} err := query.All(&amp;posts, request.Param(\"id\")) if err != nil { log.Error(err) } request.WriteResponse(data) }) . RDB will take argument, generate the sql and query to db then map the SQL rows while keeping track of those relationships. Results: . rows: blog_id | blog_title | posts_id | posts_name | author_id | author_username 1 | Foo | 1 | Bar | 1 | John 1 | Foo | 2 | Baz | 1 | John 2 | Egg | 3 | Beacon | 2 | Ed blogs: [{ \"blog_id\": 1, \"blog_title\": \"Foo\", \"author\": { \"author_id\": 1, \"author_username\": \"John\" }, \"posts\": [{ \"post_id\": 1, \"posts_name\": \"Bar\" }, { \"post_id\": 2, \"posts_name\": \"Baz\" }] }, { \"blog_id\": 2, \"blog_title\": \"Egg\", \"author\": { \"author_id\": 2, \"author_username\": \"Ed\" }, \"posts\": [{ \"post_id\": 3, \"posts_name\": \"Beacon\" }] }] . Column and Field Names . RDB will match your SQL columns with corresponding fields. You can use a “db” tag to represent a specific column name. Example: . type Blog struct { // When tag is not used, the snake case of the fiels is used BlogId int // expected column name : \"blog_id\" // When tag is specified, it takes priority Abc string `db:\"blog_title\"` // expected column name: \"blog_title\" // If you define multiple fiels with the same struct, // you can use a tag to identify a column prefix // (with underscore concatination) // possible column names: \"writer_author_id\", \"author_id\" Writer Author `db: \"writer\"` // possible column names: \"rewiewer_author_id\", \"author_id\", Reviewer Author `db: \"reviewer\"` } type Author struct { AuthorId int `db:\"author_id\"` } . Data Types and Relationships . Any primative types, time.Time, protobuf Timestamp, and sql.NullX can be loaded. These types are one-to-one mapped with your SQL columns . To define more complex SQL relationships use slices and structs as in example below: . type Blog struct { BlogId int // Will map directly with \"blog_id\" column // If your SQL data can be \"null\", use pointers or sql.NullX AuthorId *int CreatedOn *timestamp.Timestamp // protobuf timestamp UpdatedOn *time.Time SonsorId sql.NullInt64 // To define has-one relationship, use nested structs // or pointer to a struct Author *Author // To define has-many relationship, use slices // options include: *[]*Post, []*Post, *[]Post, []Post Posts []*Post // If your has-many relationship corresponds to one column, // you can use a slice of a settable type TagIds []int `db:\"tag_id\"` CommentIds []sql.NullInt64 `db:\"comment_id\"` } . Important Note . RDB removes any duplicate rows. This is a side effect of the data mapping as it is unclear which object to instantiate if the same data arrives more than once. If this is not a desired outcome, you should include a uniquely identifiable columns in your query and the corresponding fields in your structs. To prevent relatively expensive reflect operations, RDB caches the structure of your struct using the column names of your query response as well as the type of your struct. RDB or Readonly Database is a fast-multi database access data reader and binder, which let the developer to access multiple database connections at same time and query them to read data very fast then cast result to structured data. ** Note: RDB is not an ORM. RDB is used for api systems to make reusable raw queries and bind http request to query and cast result to struct without to much overhead ** . Example: . 1- Create connection and add to rdp pool for later use: . rdb.Register() err := rdb.CreateConnection(\"localhost\", \"mysql\", \"root:password@localhost/mydb?charset=utf8&amp;parseTime=True\") if err != nil { log.Fatal(err) } . 2- Access db object: . var db = rdb.GetDBO(\"localhost\") if db == nil { log.Fatal(\"Null db\") } . 3- Define Reusable Query, http parser and struct: . for query and structure refer to [[jackskj/carta|https://github.com/jackskj/carta]] and for data validation refer to [[go-playground/validator|https://github.com/go-playground/validator]] . query := db.Query(` SELECT id as blog_id, title as blog_title, P.id as posts_id, P.name as posts_name, A.id as author_id, A.username as author_username FROM blog left outer join author A on blog.author_id = A.id left outer join post P on blog.id = P.blog_id WHERE blog.id_category = ? `) type Blog struct { Id int `db:\"blog_id\"` Title string `db:\"blog_title\"` Posts []Post Author Author } type Post struct { Id int `db:\"posts_id\"` Name string `db:\"posts_name\"` } type Author struct { Id int `db:\"author_id\"` Username string `db:\"author_username\"` } //optional: use http parser to auto acquire params from http call parser := &amp;rdb.Parser{ Params: []rdb.Param{ // { parameter name , parameter source (URL,Get,Post,Header,Any) , validator based on https://github.com/go-playground/validator } {\"id\", rdb.URL, \"numeric\"}, }, } query.SetParser(parser) . 4- Manipulating parsed params if needed: . parser.Processor = func(params []string) []string { params[0] = strconv.Itoa( lib.ParseSafeInt(params[0]) + 1 ) // add 1 to first arg return params } . 5- Create API: . //with parser evo.Get(\"/api/blog/:id\", func(request *evo.Request) { posts := []Blog{} err := query.All(&amp;posts, request) if err != nil { log.Error(err) } request.WriteResponse(data) }) // without http parser evo.Get(\"/api/blog/:id\", func(request *evo.Request) { posts := []Blog{} err := query.All(&amp;posts, request.Param(\"id\")) if err != nil { log.Error(err) } request.WriteResponse(data) }) . RDB will take argument, generate the sql and query to db then map the SQL rows while keeping track of those relationships. Results: . rows: blog_id | blog_title | posts_id | posts_name | author_id | author_username 1 | Foo | 1 | Bar | 1 | John 1 | Foo | 2 | Baz | 1 | John 2 | Egg | 3 | Beacon | 2 | Ed blogs: [{ \"blog_id\": 1, \"blog_title\": \"Foo\", \"author\": { \"author_id\": 1, \"author_username\": \"John\" }, \"posts\": [{ \"post_id\": 1, \"posts_name\": \"Bar\" }, { \"post_id\": 2, \"posts_name\": \"Baz\" }] }, { \"blog_id\": 2, \"blog_title\": \"Egg\", \"author\": { \"author_id\": 2, \"author_username\": \"Ed\" }, \"posts\": [{ \"post_id\": 3, \"posts_name\": \"Beacon\" }] }] . Column and Field Names . RDB will match your SQL columns with corresponding fields. You can use a “db” tag to represent a specific column name. Example: . type Blog struct { // When tag is not used, the snake case of the fiels is used BlogId int // expected column name : \"blog_id\" // When tag is specified, it takes priority Abc string `db:\"blog_title\"` // expected column name: \"blog_title\" // If you define multiple fiels with the same struct, // you can use a tag to identify a column prefix // (with underscore concatination) // possible column names: \"writer_author_id\", \"author_id\" Writer Author `db: \"writer\"` // possible column names: \"rewiewer_author_id\", \"author_id\", Reviewer Author `db: \"reviewer\"` } type Author struct { AuthorId int `db:\"author_id\"` } . Data Types and Relationships . Any primative types, time.Time, protobuf Timestamp, and sql.NullX can be loaded. These types are one-to-one mapped with your SQL columns . To define more complex SQL relationships use slices and structs as in example below: . type Blog struct { BlogId int // Will map directly with \"blog_id\" column // If your SQL data can be \"null\", use pointers or sql.NullX AuthorId *int CreatedOn *timestamp.Timestamp // protobuf timestamp UpdatedOn *time.Time SonsorId sql.NullInt64 // To define has-one relationship, use nested structs // or pointer to a struct Author *Author // To define has-many relationship, use slices // options include: *[]*Post, []*Post, *[]Post, []Post Posts []*Post // If your has-many relationship corresponds to one column, // you can use a slice of a settable type TagIds []int `db:\"tag_id\"` CommentIds []sql.NullInt64 `db:\"comment_id\"` } . Important Note . RDB removes any duplicate rows. This is a side effect of the data mapping as it is unclear which object to instantiate if the same data arrives more than once. If this is not a desired outcome, you should include a uniquely identifiable columns in your query and the corresponding fields in your structs. To prevent relatively expensive reflect operations, RDB caches the structure of your struct using the column names of your query response as well as the type of your struct. ",
    "url": "http://localhost:4000/docs/rdb/",
    "relUrl": "/docs/rdb/"
  },"11": {
    "doc": "Request Context",
    "title": "Request",
    "content": " ",
    "url": "http://localhost:4000/docs/request/#request",
    "relUrl": "/docs/request/#request"
  },"12": {
    "doc": "Request Context",
    "title": "Accepts",
    "content": "Checks, if the specified extensions or content types are acceptable. Based on the request’s Accept HTTP header. request.Accepts(types ...string) string request.AcceptsCharsets(charsets ...string) string request.AcceptsEncodings(encodings ...string) string request.AcceptsLanguages(langs ...string) string . // Accept: text/*, application/json app.Get(\"/\", func(request *evo.Request) { request.Accepts(\"html\") // \"html\" request.Accepts(\"text/html\") // \"text/html\" request.Accepts(\"json\", \"text\") // \"json\" request.Accepts(\"application/json\") // \"application/json\" request.Accepts(\"image/png\") // \"\" request.Accepts(\"png\") // \"\" }) . EVO provides similar functions for the other accept headers. // Accept-Charset: utf-8, iso-8859-1;q=0.2 // Accept-Encoding: gzip, compress;q=0.2 // Accept-Language: en;q=0.8, nl, ru app.Get(\"/\", func(request *evo.Request) { request.AcceptsCharsets(\"utf-16\", \"iso-8859-1\") // \"iso-8859-1\" request.AcceptsEncodings(\"compress\", \"br\") // \"compress\" request.AcceptsLanguages(\"pt\", \"nl\", \"ru\") // \"nl\" }) . ",
    "url": "http://localhost:4000/docs/request/#accepts",
    "relUrl": "/docs/request/#accepts"
  },"13": {
    "doc": "Request Context",
    "title": "Append",
    "content": "Appends the specified value to the HTTP response header field. If the header is not already set, it creates the header with the specified value. request.Append(field, values ...string) . app.Get(\"/\", func(request *evo.Request) { request.Append(\"Link\", \"http://google.com\", \"http://localhost\") // =&gt; Link: http://localhost, http://google.com request.Append(\"Link\", \"Test\") // =&gt; Link: http://localhost, http://google.com, Test }) . ",
    "url": "http://localhost:4000/docs/request/#append",
    "relUrl": "/docs/request/#append"
  },"14": {
    "doc": "Request Context",
    "title": "Attachment",
    "content": "Sets the HTTP response Content-Disposition header field to attachment. request.Attachment(file ...string) . app.Get(\"/\", func(request *evo.Request) { request.Attachment() // =&gt; Content-Disposition: attachment request.Attachment(\"./upload/images/logo.png\") // =&gt; Content-Disposition: attachment; filename=\"logo.png\" // =&gt; Content-Type: image/png }) . ",
    "url": "http://localhost:4000/docs/request/#attachment",
    "relUrl": "/docs/request/#attachment"
  },"15": {
    "doc": "Request Context",
    "title": "App",
    "content": "Returns the *App reference so you could easily access all application settings. request.App() *App . app.Get(\"/bodylimit\", func(request *evo.Request) { bodylimit := request.App().Settings.BodyLimit request.Send(bodylimit) }) . ",
    "url": "http://localhost:4000/docs/request/#app",
    "relUrl": "/docs/request/#app"
  },"16": {
    "doc": "Request Context",
    "title": "BaseURL",
    "content": "Returns base URL (protocol + host) as a string. request.BaseURL() string . // GET https://example.com/page#chapter-1 app.Get(\"/\", func(request *evo.Request) { request.BaseURL() // https://example.com }) . ",
    "url": "http://localhost:4000/docs/request/#baseurl",
    "relUrl": "/docs/request/#baseurl"
  },"17": {
    "doc": "Request Context",
    "title": "Body",
    "content": "Contains the raw body submitted in a POST request. request.Body() string . // curl -X POST http://localhost:8080 -d user=john app.Post(\"/\", func(request *evo.Request) { // Get raw body from POST request: request.Body() // user=john }) . Returned value is only valid within the handler. Do not store any references. Make copies or use the Immutable setting instead. Read more… . ",
    "url": "http://localhost:4000/docs/request/#body",
    "relUrl": "/docs/request/#body"
  },"18": {
    "doc": "Request Context",
    "title": "BodyParser",
    "content": "Binds the request body to a struct. BodyParser supports decoding query parameters and the following content types based on the Content-Type header: . | application/json | application/xml | application/x-www-form-urlencoded | multipart/form-data | . request.BodyParser(out interface{}) error . // Field names should start with an uppercase letter type Person struct { Name string `json:\"name\" xml:\"name\" form:\"name\" query:\"name\"` Pass string `json:\"pass\" xml:\"pass\" form:\"pass\" query:\"pass\"` } app.Post(\"/\", func(request *evo.Request) { p := new(Person) if err := request.BodyParser(p); err != nil { log.Fatal(err) } log.Println(p.Name) // john log.Println(p.Pass) // doe }) // Run tests with the following curl commands // curl -X POST -H \"Content-Type: application/json\" --data \"{\\\"name\\\":\\\"john\\\",\\\"pass\\\":\\\"doe\\\"}\" localhost:3000 // curl -X POST -H \"Content-Type: application/xml\" --data \"&lt;login&gt;&lt;name&gt;john&lt;/name&gt;&lt;pass&gt;doe&lt;/pass&gt;&lt;/login&gt;\" localhost:3000 // curl -X POST -H \"Content-Type: application/x-www-form-urlencoded\" --data \"name=john&amp;pass=doe\" localhost:3000 // curl -X POST -F name=john -F pass=doe http://localhost:3000 // curl -X POST \"http://localhost:3000/?name=john&amp;pass=doe\" . ",
    "url": "http://localhost:4000/docs/request/#bodyparser",
    "relUrl": "/docs/request/#bodyparser"
  },"19": {
    "doc": "Request Context",
    "title": "ClearCookie",
    "content": "Expire a client cookie (or all cookies if left empty) . request.ClearCookie(key ...string) . app.Get(\"/\", func(request *evo.Request) { // Clears all cookies: request.ClearCookie() // Expire specific cookie by name: request.ClearCookie(\"user\") // Expire multiple cookies by names: request.ClearCookie(\"token\", \"session\", \"track_id\", \"version\") }) . ",
    "url": "http://localhost:4000/docs/request/#clearcookie",
    "relUrl": "/docs/request/#clearcookie"
  },"20": {
    "doc": "Request Context",
    "title": "Context",
    "content": "Returns context.Context that carries a deadline, a cancellation signal, and other values across API boundaries. Signature . request.Context() context.Context . ",
    "url": "http://localhost:4000/docs/request/#context",
    "relUrl": "/docs/request/#context"
  },"21": {
    "doc": "Request Context",
    "title": "Cookie",
    "content": "Set cookie . Signature . request.Cookie(*Cookie) . type Cookie struct { Name string Value string Path string Domain string Expires time.Time Secure bool HTTPOnly bool SameSite string // lax, strict, none } . app.Get(\"/\", func(request *evo.Request) { // Create cookie cookie := new(fiber.Cookie) cookie.Name = \"john\" cookie.Value = \"doe\" cookie.Expires = time.Now().Add(24 * time.Hour) // Set cookie request.Cookie(cookie) }) . ",
    "url": "http://localhost:4000/docs/request/#cookie",
    "relUrl": "/docs/request/#cookie"
  },"22": {
    "doc": "Request Context",
    "title": "Cookies",
    "content": "Get cookie value by key. Signatures . request.Cookies(key string) string . app.Get(\"/\", func(request *evo.Request) { // Get cookie by key: request.Cookies(\"name\") // \"john\" }) . Returned value is only valid within the handler. Do not store any references. Make copies or use the Immutable setting instead. Read more… . ",
    "url": "http://localhost:4000/docs/request/#cookies",
    "relUrl": "/docs/request/#cookies"
  },"23": {
    "doc": "Request Context",
    "title": "Download",
    "content": "Transfers the file from path as an attachment. Typically, browsers will prompt the user for download. By default, the Content-Disposition header filename= parameter is the file path (this typically appears in the browser dialog). Override this default with the filename parameter. request.Download(path, filename ...string) error . app.Get(\"/\", func(request *evo.Request) { if err := request.Download(\"./files/report-12345.pdf\"); err != nil { request.Next(err) // Pass err to EVO } // =&gt; Download report-12345.pdf if err := request.Download(\"./files/report-12345.pdf\", \"report.pdf\"); err != nil { request.Next(err) // Pass err to EVO } // =&gt; Download report.pdf }) . ",
    "url": "http://localhost:4000/docs/request/#download",
    "relUrl": "/docs/request/#download"
  },"24": {
    "doc": "Request Context",
    "title": "Fasthttp",
    "content": "You can still access and use all Fasthttp methods and properties. Signature . Please read the Fasthttp Documentation for more information. Example . app.Get(\"/\", func(request *evo.Request) { request.Fasthttp.Request.Header.Method() // =&gt; []byte(\"GET\") request.Fasthttp.Response.Write([]byte(\"Hello, World!\")) // =&gt; \"Hello, World!\" }) . ",
    "url": "http://localhost:4000/docs/request/#fasthttp",
    "relUrl": "/docs/request/#fasthttp"
  },"25": {
    "doc": "Request Context",
    "title": "Error",
    "content": "This contains the error information that thrown by a panic or passed via Next method. request.Error() error . func main() { evo.Setup() evo.Post(\"/api/register\", func (request *evo.Request) { if err := request.JSON(&amp;User); err != nil { request.Next(err) } }) evo.Get(\"/api/user\", func (request *evo.Request) { if err := request.JSON(&amp;User); err != nil { request.Next(err) } }) evo.Put(\"/api/update\", func (request *evo.Request) { if err := request.JSON(&amp;User); err != nil { request.Next(err) } }) evo.Use(\"/api\", func(request *evo.Request) { request.Set(\"Content-Type\", \"application/json\") request.Status(500).Send(request.Error()) }) evo.Run() } . ",
    "url": "http://localhost:4000/docs/request/#error",
    "relUrl": "/docs/request/#error"
  },"26": {
    "doc": "Request Context",
    "title": "Format",
    "content": "Performs content-negotiation on the Accept HTTP header. It uses Accepts to select a proper format. If the header is not specified or there is no proper format, text/plain is used. request.Format(body interface{}) . app.Get(\"/\", func(request *evo.Request) { // Accept: text/plain request.Format(\"Hello, World!\") // =&gt; Hello, World! // Accept: text/html request.Format(\"Hello, World!\") // =&gt; &lt;p&gt;Hello, World!&lt;/p&gt; // Accept: application/json request.Format(\"Hello, World!\") // =&gt; \"Hello, World!\" }) . ",
    "url": "http://localhost:4000/docs/request/#format",
    "relUrl": "/docs/request/#format"
  },"27": {
    "doc": "Request Context",
    "title": "FormFile",
    "content": "MultipartForm files can be retrieved by name, the first file from the given key is returned. request.FormFile(name string) (*multipart.FileHeader, error) . app.Post(\"/\", func(request *evo.Request) { // Get first file from form field \"document\": file, err := request.FormFile(\"document\") // Check for errors: if err == nil { // Save file to root directory: request.SaveFile(file, fmt.Sprintf(\"./%s\", file.Filename)) } }) . ",
    "url": "http://localhost:4000/docs/request/#formfile",
    "relUrl": "/docs/request/#formfile"
  },"28": {
    "doc": "Request Context",
    "title": "FormValue",
    "content": "Any form values can be retrieved by name, the first value from the given key is returned. request.FormValue(name string) string . app.Post(\"/\", func(request *evo.Request) { // Get first value from form field \"name\": request.FormValue(\"name\") // =&gt; \"john\" or \"\" if not exist }) . Returned value is only valid within the handler. Do not store any references. Make copies or use the Immutable setting instead. Read more… . ",
    "url": "http://localhost:4000/docs/request/#formvalue",
    "relUrl": "/docs/request/#formvalue"
  },"29": {
    "doc": "Request Context",
    "title": "Fresh",
    "content": "https://expressjs.com/en/4x/api.html#req.fresh . Not implemented yet, pull requests are welcome! . ",
    "url": "http://localhost:4000/docs/request/#fresh",
    "relUrl": "/docs/request/#fresh"
  },"30": {
    "doc": "Request Context",
    "title": "Get",
    "content": "Returns the HTTP request header specified by field. The match is case-insensitive. request.Get(field string) string . app.Get(\"/\", func(request *evo.Request) { request.Get(\"Content-Type\") // \"text/plain\" request.Get(\"CoNtEnT-TypE\") // \"text/plain\" request.Get(\"something\") // \"\" }) . Returned value is only valid within the handler. Do not store any references. Make copies or use the Immutable setting instead. Read more… . ",
    "url": "http://localhost:4000/docs/request/#get",
    "relUrl": "/docs/request/#get"
  },"31": {
    "doc": "Request Context",
    "title": "Hostname",
    "content": "Contains the hostname derived from the Host HTTP header. request.Hostname() string . // GET http://google.com/search app.Get(\"/\", func(request *evo.Request) { request.Hostname() // \"google.com\" }) . Returned value is only valid within the handler. Do not store any references. Make copies or use the Immutable setting instead. Read more… . ",
    "url": "http://localhost:4000/docs/request/#hostname",
    "relUrl": "/docs/request/#hostname"
  },"32": {
    "doc": "Request Context",
    "title": "IP",
    "content": "Returns the remote IP address of the request. request.IP() string . app.Get(\"/\", func(request *evo.Request) { request.IP() // \"127.0.0.1\" }) . ",
    "url": "http://localhost:4000/docs/request/#ip",
    "relUrl": "/docs/request/#ip"
  },"33": {
    "doc": "Request Context",
    "title": "IPs",
    "content": "Returns an array of IP addresses specified in the X-Forwarded-For request header. request.IPs() []string . // X-Forwarded-For: proxy1, 127.0.0.1, proxy3 app.Get(\"/\", func(request *evo.Request) { request.IPs() // [\"proxy1\", \"127.0.0.1\", \"proxy3\"] }) . ",
    "url": "http://localhost:4000/docs/request/#ips",
    "relUrl": "/docs/request/#ips"
  },"34": {
    "doc": "Request Context",
    "title": "Is",
    "content": "Returns the matching content type, if the incoming request’s Content-Type HTTP header field matches the MIME type specified by the type parameter. If the request has no body, it returns false. request.Is(t string) bool . // Content-Type: text/html; charset=utf-8 app.Get(\"/\", func(request *evo.Request) { request.Is(\"html\") // true request.Is(\".html\") // true request.Is(\"json\") // false }) . ",
    "url": "http://localhost:4000/docs/request/#is",
    "relUrl": "/docs/request/#is"
  },"35": {
    "doc": "Request Context",
    "title": "JSON",
    "content": "Converts any interface or string to JSON using Jsoniter. JSON also sets the content header to application/json. request.JSON(v interface{}) error . type SomeStruct struct { Name string Age uint8 } app.Get(\"/json\", func(request *evo.Request) { // Create data struct: data := SomeStruct{ Name: \"Grame\", Age: 20, } if err := request.JSON(data); err != nil { request.Status(500).Send(err) return } // =&gt; Content-Type: application/json // =&gt; \"{\"Name\": \"Grame\", \"Age\": 20}\" if err := request.JSON(map[string]interface{}{ \"name\": \"Grame\", \"age\": 20, }); err != nil { request.Status(500).Send(err) return } // =&gt; Content-Type: application/json // =&gt; \"{\"name\": \"Grame\", \"age\": 20}\" }) . ",
    "url": "http://localhost:4000/docs/request/#json",
    "relUrl": "/docs/request/#json"
  },"36": {
    "doc": "Request Context",
    "title": "JSONP",
    "content": "Sends a JSON response with JSONP support. This method is identical to JSON, except that it opts-in to JSONP callback support. By default, the callback name is simply callback. Override this by passing a named string in the method. request.JSONP(v interface{}, callback ...string) error . type SomeStruct struct { name string age uint8 } app.Get(\"/\", func(request *evo.Request) { // Create data struct: data := SomeStruct{ name: \"Grame\", age: 20, } request.JSONP(data) // =&gt; callback({\"name\": \"Grame\", \"age\": 20}) request.JSONP(data, \"customFunc\") // =&gt; customFunc({\"name\": \"Grame\", \"age\": 20}) }) . ",
    "url": "http://localhost:4000/docs/request/#jsonp",
    "relUrl": "/docs/request/#jsonp"
  },"37": {
    "doc": "Request Context",
    "title": "Links",
    "content": "Joins the links followed by the property to populate the response’s Link HTTP header field. request.Links(link ...string) . app.Get(\"/\", func(request *evo.Request) { request.Link( \"http://api.example.com/users?page=2\", \"next\", \"http://api.example.com/users?page=5\", \"last\", ) // Link: &lt;http://api.example.com/users?page=2&gt;; rel=\"next\", // &lt;http://api.example.com/users?page=5&gt;; rel=\"last\" }) . ",
    "url": "http://localhost:4000/docs/request/#links",
    "relUrl": "/docs/request/#links"
  },"38": {
    "doc": "Request Context",
    "title": "Locals",
    "content": "Method that stores string variables scoped to the request and therefore available only to the routes that match the request. This is useful, if you want to pass some specific data to the next middleware. request.Locals(key string, value ...interface{}) interface{} . app.Get(\"/\", func(request *evo.Request) { request.Locals(\"user\", \"admin\") request.Next() }) app.Get(\"/admin\", func(request *evo.Request) { if request.Locals(\"user\") == \"admin\" { request.Status(200).Send(\"Welcome, admin!\") } else { request.SendStatus(403) // =&gt; 403 Forbidden } }) . ",
    "url": "http://localhost:4000/docs/request/#locals",
    "relUrl": "/docs/request/#locals"
  },"39": {
    "doc": "Request Context",
    "title": "Location",
    "content": "Sets the response Location HTTP header to the specified path parameter. request.Location(path string) . app.Post(\"/\", func(request *evo.Request) { request.Location(\"http://example.com\") request.Location(\"/foo/bar\") }) . ",
    "url": "http://localhost:4000/docs/request/#location",
    "relUrl": "/docs/request/#location"
  },"40": {
    "doc": "Request Context",
    "title": "Method",
    "content": "Contains a string corresponding to the HTTP method of the request: GET, POST, PUT and so on. Optionally, you could override the method by passing a string. request.Method(override ...string) string . app.Post(\"/\", func(request *evo.Request) { request.Method() // \"POST\" }) . ",
    "url": "http://localhost:4000/docs/request/#method",
    "relUrl": "/docs/request/#method"
  },"41": {
    "doc": "Request Context",
    "title": "MultipartForm",
    "content": "To access multipart form entries, you can parse the binary with MultipartForm(). This returns a map[string][]string, so given a key the value will be a string slice. request.MultipartForm() (*multipart.Form, error) . app.Post(\"/\", func(request *evo.Request) { // Parse the multipart form: if form, err := request.MultipartForm(); err == nil { // =&gt; *multipart.Form if token := form.Value[\"token\"]; len(token) &gt; 0 { // Get key value: fmt.Println(token[0]) } // Get all files from \"documents\" key: files := form.File[\"documents\"] // =&gt; []*multipart.FileHeader // Loop through files: for _, file := range files { fmt.Println(file.Filename, file.Size, file.Header[\"Content-Type\"][0]) // =&gt; \"tutorial.pdf\" 360641 \"application/pdf\" // Save the files to disk: request.SaveFile(file, fmt.Sprintf(\"./%s\", file.Filename)) } } }) . ",
    "url": "http://localhost:4000/docs/request/#multipartform",
    "relUrl": "/docs/request/#multipartform"
  },"42": {
    "doc": "Request Context",
    "title": "Next",
    "content": "When Next is called, it executes the next method in the stack that matches the current route. You can pass an error struct within the method for custom error handling. request.Next(err ...error) . app.Get(\"/\", func(request *evo.Request) { fmt.Println(\"1st route!\") request.Next() }) app.Get(\"*\", func(request *evo.Request) { fmt.Println(\"2nd route!\") request.Next(fmt.Errorf(\"Some error\")) }) app.Get(\"/\", func(request *evo.Request) { fmt.Println(request.Error()) // =&gt; \"Some error\" fmt.Println(\"3rd route!\") request.Send(\"Hello, World!\") }) . ",
    "url": "http://localhost:4000/docs/request/#next",
    "relUrl": "/docs/request/#next"
  },"43": {
    "doc": "Request Context",
    "title": "OriginalURL",
    "content": "Contains the original request URL. request.OriginalURL() string . // GET http://example.com/search?q=something app.Get(\"/\", func(request *evo.Request) { request.OriginalURL() // \"/search?q=something\" }) . Returned value is only valid within the handler. Do not store any references. Make copies or use the Immutable setting instead. Read more… . ",
    "url": "http://localhost:4000/docs/request/#originalurl",
    "relUrl": "/docs/request/#originalurl"
  },"44": {
    "doc": "Request Context",
    "title": "Params",
    "content": "Method can be used to get the route parameters. Defaults to empty string (\"\"), if the param doesn’t exist. request.Params(param string) string . // GET http://example.com/user/fenny app.Get(\"/user/:name\", func(request *evo.Request) { request.Params(\"name\") // \"fenny\" }) . Returned value is only valid within the handler. Do not store any references. Make copies or use the Immutable setting instead. Read more…__ . ",
    "url": "http://localhost:4000/docs/request/#params",
    "relUrl": "/docs/request/#params"
  },"45": {
    "doc": "Request Context",
    "title": "Path",
    "content": "Contains the path part of the request URL. Optionally, you could override the path by passing a string. request.Path(override ...string) string . // GET http://example.com/users?sort=desc app.Get(\"/users\", func(request *evo.Request) { request.Path() // \"/users\" }) . ",
    "url": "http://localhost:4000/docs/request/#path",
    "relUrl": "/docs/request/#path"
  },"46": {
    "doc": "Request Context",
    "title": "Protocol",
    "content": "Contains the request protocol string: http or https for TLS requests. request.Protocol() string . // GET http://example.com app.Get(\"/\", func(request *evo.Request) { request.Protocol() // \"http\" }) . ",
    "url": "http://localhost:4000/docs/request/#protocol",
    "relUrl": "/docs/request/#protocol"
  },"47": {
    "doc": "Request Context",
    "title": "Query",
    "content": "This property is an object containing a property for each query string parameter in the route. If there is no query string, it returns an empty string. request.Query(parameter string) string . // GET http://example.com/shoes?order=desc&amp;brand=nike app.Get(\"/\", func(request *evo.Request) { request.Query(\"order\") // \"desc\" request.Query(\"brand\") // \"nike\" }) . Returned value is only valid within the handler. Do not store any references. Make copies or use the Immutable setting instead. Read more… . ",
    "url": "http://localhost:4000/docs/request/#query",
    "relUrl": "/docs/request/#query"
  },"48": {
    "doc": "Request Context",
    "title": "Range",
    "content": "An struct containg the type and a slice of ranges will be returned. request.Range(int size) . // Range: bytes=500-700, 700-900 app.Get(\"/\", func(request *evo.Request) { b := request.Range(1000) if b.Type == \"bytes\" { for r := range r.Ranges { fmt.Println(r) // [500, 700] } } }) . ",
    "url": "http://localhost:4000/docs/request/#range",
    "relUrl": "/docs/request/#range"
  },"49": {
    "doc": "Request Context",
    "title": "Redirect",
    "content": "Redirects to the URL derived from the specified path, with specified status, a positive integer that corresponds to an HTTP status code. If not specified, status defaults to 302 Found. request.Redirect(path string, status ...int) . app.Get(\"/\", func(request *evo.Request) { request.Redirect(\"/foo/bar\") request.Redirect(\"../login\") request.Redirect(\"http://example.com\") request.Redirect(\"http://example.com\", 301) }) . ",
    "url": "http://localhost:4000/docs/request/#redirect",
    "relUrl": "/docs/request/#redirect"
  },"50": {
    "doc": "Request Context",
    "title": "Route",
    "content": "Contains the matched Route struct. request.Route() *Route . // http://localhost:8080/hello request.Get(\"/hello\", func(request *evo.Request) { r := request.Route() fmt.Println(r.Method, r.Path, r.Params, r.Regexp, r.Handler) }) request.Post(\"/:api?\", func(request *evo.Request) { request.Route() // =&gt; {GET /hello [] nil 0x7b49e0} }) . ",
    "url": "http://localhost:4000/docs/request/#route",
    "relUrl": "/docs/request/#route"
  },"51": {
    "doc": "Request Context",
    "title": "SaveFile",
    "content": "Method is used to save any multipart file to disk. request.SaveFile(fh *multipart.FileHeader, path string) . request.Post(\"/\", func(request *evo.Request) { // Parse the multipart form: if form, err := request.MultipartForm(); err == nil { // =&gt; *multipart.Form // Get all files from \"documents\" key: files := form.File[\"documents\"] // =&gt; []*multipart.FileHeader // Loop through files: for _, file := range files { fmt.Println(file.Filename, file.Size, file.Header[\"Content-Type\"][0]) // =&gt; \"tutorial.pdf\" 360641 \"application/pdf\" // Save the files to disk: request.SaveFile(file, fmt.Sprintf(\"./%s\", file.Filename)) } } }) . ",
    "url": "http://localhost:4000/docs/request/#savefile",
    "relUrl": "/docs/request/#savefile"
  },"52": {
    "doc": "Request Context",
    "title": "Secure",
    "content": "A boolean property, that is true , if a TLS connection is established. request.Secure() bool . // Secure() method is equivalent to: request.Protocol() == \"https\" . ",
    "url": "http://localhost:4000/docs/request/#secure",
    "relUrl": "/docs/request/#secure"
  },"53": {
    "doc": "Request Context",
    "title": "Send",
    "content": "Sets the HTTP response body. The Send body can be of any type. request.Send(body ...interface{}) . request.Get(\"/\", func(request *evo.Request) { request.Send(\"Hello, World!\") // =&gt; \"Hello, World!\" request.Send([]byte(\"Hello, World!\")) // =&gt; \"Hello, World!\" request.Send(123) // =&gt; 123 }) . EVO also provides SendBytes ,SendString and SendStream methods for raw inputs. Use this, if you don’t need type assertion, recommended for faster performance. request.SendBytes(b []byte) request.SendString(s string) request.SendStream(r io.Reader, s ...int) . app.Get(\"/\", func(request *evo.Request) { request.SendByte([]byte(\"Hello, World!\")) // =&gt; \"Hello, World!\" request.SendString(\"Hello, World!\") // =&gt; \"Hello, World!\" request.SendStream(bytes.NewReader([]byte(\"Hello, World!\"))) // =&gt; \"Hello, World!\" }) . ",
    "url": "http://localhost:4000/docs/request/#send",
    "relUrl": "/docs/request/#send"
  },"54": {
    "doc": "Request Context",
    "title": "SendFile",
    "content": "Transfers the file from the given path. Sets the Content-Type response HTTP header field based on the filenames extension. Method use gzipping by default, set it to true to disable. request.SendFile(path string, compress ...bool) error . app.Get(\"/not-found\", func(request *evo.Request) { if err := request.SendFile(\"./public/404.html\"); err != nil { request.Next(err) // pass err to ErrorHandler } // Enable compression if err := request.SendFile(\"./static/index.html\", true); err != nil { request.Next(err) // pass err to ErrorHandler } }) . ",
    "url": "http://localhost:4000/docs/request/#sendfile",
    "relUrl": "/docs/request/#sendfile"
  },"55": {
    "doc": "Request Context",
    "title": "SendStatus",
    "content": "Sets the status code and the correct status message in the body, if the response body is empty. request.SendStatus(status int) . app.Get(\"/not-found\", func(request *evo.Request) { request.SendStatus(415) // =&gt; 415 \"Unsupported Media Type\" request.Send(\"Hello, World!\") request.SendStatus(415) // =&gt; 415 \"Hello, World!\" }) . ",
    "url": "http://localhost:4000/docs/request/#sendstatus",
    "relUrl": "/docs/request/#sendstatus"
  },"56": {
    "doc": "Request Context",
    "title": "Set",
    "content": "Sets the response’s HTTP header field to the specified key, value. request.Set(field, value string) . app.Get(\"/\", func(request *evo.Request) { request.Set(\"Content-Type\", \"text/plain\") // =&gt; \"Content-type: text/plain\" }) . ",
    "url": "http://localhost:4000/docs/request/#set",
    "relUrl": "/docs/request/#set"
  },"57": {
    "doc": "Request Context",
    "title": "Stale",
    "content": "https://expressjs.com/en/4x/api.html#req.fresh . Not implemented yet, pull requests are welcome! . ",
    "url": "http://localhost:4000/docs/request/#stale",
    "relUrl": "/docs/request/#stale"
  },"58": {
    "doc": "Request Context",
    "title": "Status",
    "content": "Sets the HTTP status for the response. Method is a chainable. request.Status(status int) . app.Get(\"/\", func(request *evo.Request) { request.Status(200) request.Status(400).Send(\"Bad Request\") request.Status(404).SendFile(\"./public/gopher.png\") }) . ",
    "url": "http://localhost:4000/docs/request/#status",
    "relUrl": "/docs/request/#status"
  },"59": {
    "doc": "Request Context",
    "title": "Subdomains",
    "content": "An array of subdomains in the domain name of the request. The application property subdomain offset, which defaults to 2, is used for determining the beginning of the subdomain segments. request.Subdomains(offset ...int) []string . // Host: \"tobi.ferrets.example.com\" app.Get(\"/\", func(request *evo.Request) { request.Subdomains() // [\"ferrets\", \"tobi\"] request.Subdomains(1) // [\"tobi\"] }) . ",
    "url": "http://localhost:4000/docs/request/#subdomains",
    "relUrl": "/docs/request/#subdomains"
  },"60": {
    "doc": "Request Context",
    "title": "Type",
    "content": "Sets the Content-Type HTTP header to the MIME type listed here specified by the file extension. request.Type(t string) string . app.Get(\"/\", func(request *evo.Request) { request.Type(\".html\") // =&gt; \"text/html\" request.Type(\"html\") // =&gt; \"text/html\" request.Type(\"json\") // =&gt; \"application/json\" request.Type(\"png\") // =&gt; \"image/png\" }) . ",
    "url": "http://localhost:4000/docs/request/#type",
    "relUrl": "/docs/request/#type"
  },"61": {
    "doc": "Request Context",
    "title": "Vary",
    "content": "Adds the given header field to the Vary response header. This will append the header, if not already listed, otherwise leaves it listed in the current location. Multiple fields are allowed. request.Vary(field ...string) . app.Get(\"/\", func(request *evo.Request) { request.Vary(\"Origin\") // =&gt; Vary: Origin request.Vary(\"User-Agent\") // =&gt; Vary: Origin, User-Agent // No duplicates request.Vary(\"Origin\") // =&gt; Vary: Origin, User-Agent request.Vary(\"Accept-Encoding\", \"Accept\") // =&gt; Vary: Origin, User-Agent, Accept-Encoding, Accept }) . ",
    "url": "http://localhost:4000/docs/request/#vary",
    "relUrl": "/docs/request/#vary"
  },"62": {
    "doc": "Request Context",
    "title": "Write",
    "content": "Appends any input to the HTTP body response. request.Write(body ...interface{}) . app.Get(\"/\", func(request *evo.Request) { request.Write(\"Hello, \") // =&gt; \"Hello, \" request.Write([]byte(\"World! \")) // =&gt; \"Hello, World! \" request.Write(123) // =&gt; \"Hello, World! 123\" }) . ",
    "url": "http://localhost:4000/docs/request/#write",
    "relUrl": "/docs/request/#write"
  },"63": {
    "doc": "Request Context",
    "title": "XHR",
    "content": "A Boolean property, that is true, if the request’s X-Requested-With header field is XMLHttpRequest, indicating that the request was issued by a client library (such as jQuery). request.XHR() bool . // X-Requested-With: XMLHttpRequest app.Get(\"/\", func(request *evo.Request) { request.XHR() // true }) . ",
    "url": "http://localhost:4000/docs/request/#xhr",
    "relUrl": "/docs/request/#xhr"
  },"64": {
    "doc": "Request Context",
    "title": "Request Context",
    "content": "EVO Request context is the upgraded version of fiber.Context with extra features. The Request struct represents the Context which hold the HTTP request and response. It has methods for the request query string, parameters, body, HTTP headers and so on. — . ",
    "url": "http://localhost:4000/docs/request/",
    "relUrl": "/docs/request/"
  },"65": {
    "doc": "Routing",
    "title": "Paths",
    "content": "Route paths, in combination with a request method, define the endpoints at which requests can be made. Route paths can be strings or string patterns. Examples of route paths based on strings . // This route path will match requests to the root route, \"/\": evo.Get(\"/\", func(request *evo.Request) { request.Send(\"root\") }) // This route path will match requests to \"/about\": evo.Get(\"/about\", func(request *evo.Request) { request.Send(\"about\") }) // This route path will match requests to \"/random.txt\": evo.Get(\"/random.txt\", func(request *evo.Request) { request.Send(\"random.txt\") }) . ",
    "url": "http://localhost:4000/docs/routing/#paths",
    "relUrl": "/docs/routing/#paths"
  },"66": {
    "doc": "Routing",
    "title": "Parameters",
    "content": "Route parameters are named URL segments that are used to capture the values specified at their position in the URL. The captured values can be retrieved using the Params function, with the name of the route parameter specified in the path as their respective keys. Name of the route parameter must be made up of characters ([A-Za-z0-9_]). Example of define routes with route parameters . // Parameters evo.Get(\"/user/:name/books/:title\", func(request *evo.Request) { request.Write(request.Params(\"name\")) request.Write(request.Params(\"title\")) }) // Wildcard evo.Get(\"/user/*\", func(request *evo.Request) { request.Send(request.Params(\"*\")) }) // Optional parameter app.Get(\"/user/:name?\", func(request *evo.Request) { request.Send(request.Params(\"name\")) }) . Since the hyphen (-) and the dot (.) are interpreted literally, they can be used along with route parameters for useful purposes. // http://localhost:3000/plantae/prunus.persica evo.Get(\"/plantae/:genus.:species\", func(request *evo.Request) { request.Params(\"genus\") // prunus request.Params(\"species\") // persica }) . // http://localhost:3000/flights/LAX-SFO evo.Get(\"/flights/:from-:to\", func(request *evo.Request) { request.Params(\"from\") // LAX request.Params(\"to\") // SFO }) . ",
    "url": "http://localhost:4000/docs/routing/#parameters",
    "relUrl": "/docs/routing/#parameters"
  },"67": {
    "doc": "Routing",
    "title": "Middleware",
    "content": "Functions, that are designed to make changes to the request or response, are called middleware functions. The Next is a Fiber router function, when called, executes the next function that matches the current route. Example of a middleware function . app.Use(func(request *evo.Request) { // Set some security headers: request.Set(\"X-XSS-Protection\", \"1; mode=block\") request.Set(\"X-Content-Type-Options\", \"nosniff\") request.Set(\"X-Download-Options\", \"noopen\") request.Set(\"Strict-Transport-Security\", \"max-age=5184000\") request.Set(\"X-Frame-Options\", \"SAMEORIGIN\") request.Set(\"X-DNS-Prefetch-Control\", \"off\") // Go to next middleware: request.Next() }) app.Get(\"/\", func(request *evo.Request) { request.Send(\"Hello, World!\") }) . Use method path is a mount or prefix path and limits middleware to only apply to any paths requested that begin with it. This means you cannot use :params on the Use method. ",
    "url": "http://localhost:4000/docs/routing/#middleware",
    "relUrl": "/docs/routing/#middleware"
  },"68": {
    "doc": "Routing",
    "title": "Grouping",
    "content": "If you have many endpoints, you can organize your routes using Group . func main() { evo.Setup() api := evo.Group(\"/api\", cors()) // /api v1 := api.Group(\"/v1\", mysql()) // /api/v1 v1.Get(\"/list\", handler) // /api/v1/list v1.Get(\"/user\", handler) // /api/v1/user v2 := api.Group(\"/v2\", mongodb()) // /api/v2 v2.Get(\"/list\", handler) // /api/v2/list v2.Get(\"/user\", handler) // /api/v2/user evo.Start() } . ",
    "url": "http://localhost:4000/docs/routing/#grouping",
    "relUrl": "/docs/routing/#grouping"
  },"69": {
    "doc": "Routing",
    "title": "Routing",
    "content": "EVO inherit the ultimate power of Fiber in background. So all the routing system is inherited from Fiber. Routing refers to how an application’s endpoints (URIs) respond to client requests. ",
    "url": "http://localhost:4000/docs/routing/",
    "relUrl": "/docs/routing/"
  },"70": {
    "doc": "Search",
    "title": "Search",
    "content": " ",
    "url": "http://localhost:4000/docs/search/",
    "relUrl": "/docs/search/"
  },"71": {
    "doc": "Search",
    "title": "Table of contents",
    "content": ". | Enable search in configuration . | Search granularity | Search previews | Search tokenizer | Display URL in search results | Display search button | . | Hiding pages from search | Generate search index when used as a gem | . Just the Docs uses lunr.js to add a client-side search interface powered by a JSON index that Jekyll generates. All search results are shown in an auto-complete style interface (there is no search results page). By default, all generated HTML pages are indexed using the following data points: . | Page title | Page content | Page URL | . ",
    "url": "http://localhost:4000/docs/search/#table-of-contents",
    "relUrl": "/docs/search/#table-of-contents"
  },"72": {
    "doc": "Search",
    "title": "Enable search in configuration",
    "content": "In your site’s _config.yml, enable search: . # Enable or disable the site search # Supports true (default) or false search_enabled: true . Search granularity . Pages are split into sections that can be searched individually. The sections are defined by the headings on the page. Each section is displayed in a separate search result. # Split pages into sections that can be searched individually # Supports 1 - 6, default: 2 search.heading_level: 2 . Search previews . A search result can contain previews that show where the search words are found in the specific section. # Maximum amount of previews per search result # Default: 3 search.previews: 3 # Maximum amount of words to display before a matched word in the preview # Default: 5 search.preview_words_before: 5 # Maximum amount of words to display after a matched word in the preview # Default: 10 search.preview_words_after: 10 . Search tokenizer . The default is for hyphens to separate tokens in search terms: gem-based is equivalent to gem based, matching either word. To allow search for hyphenated words: . # Set the search token separator # Default: /[\\s\\-/]+/ # Example: enable support for hyphenated search words search.tokenizer_separator: /[\\s/]+/ . Display URL in search results . # Display the relative url in search results # Supports true (default) or false search.rel_url: false . Display search button . The search button displays in the bottom right corner of the screen and triggers the search input when clicked. # Enable or disable the search button that appears in the bottom right corner of every page # Supports true or false (default) search.button: true . ",
    "url": "http://localhost:4000/docs/search/#enable-search-in-configuration",
    "relUrl": "/docs/search/#enable-search-in-configuration"
  },"73": {
    "doc": "Search",
    "title": "Hiding pages from search",
    "content": "Sometimes you might have a page that you don’t want to be indexed for the search nor to show up in search results, e.g, a 404 page. To exclude a page from search, add the search_exclude: true parameter to the page’s YAML front matter: . Example . --- layout: default title: Page not found nav_exclude: true search_exclude: true --- . ",
    "url": "http://localhost:4000/docs/search/#hiding-pages-from-search",
    "relUrl": "/docs/search/#hiding-pages-from-search"
  },"74": {
    "doc": "Search",
    "title": "Generate search index when used as a gem",
    "content": "If you use Just the Docs as a remote theme, you do not need the following steps. If you use the theme as a gem, you must initialize the search by running this rake command that comes with just-the-docs: . $ bundle exec just-the-docs rake search:init . This command creates the assets/js/zzzz-search-data.json file that Jekyll uses to create your search index. Alternatively, you can create the file manually with this content. ",
    "url": "http://localhost:4000/docs/search/#generate-search-index-when-used-as-a-gem",
    "relUrl": "/docs/search/#generate-search-index-when-used-as-a-gem"
  },"75": {
    "doc": "Why EVO?",
    "title": "Why EVO?",
    "content": "The aim of EVO is to develop api/dashboard faster and more structured. So the EVO has overview over both backend and frontend concerns at the same time which let the developer concentrate more over the logic than dealing with the low level programming; In other hand EVO is based on powerful and fastest libraries which let it to achieve good performance. | EVO is based on modular system which let developer to load only the tools that is needed. | EVO may compile on MACOS/Linux/Windows without any restriction | EVO may compile on arm and aarch processors along side X86 | Based on MVC | . Response +-----------------------------------------------------------------------------+ v | +---+--+ Request +----------+ +--------+ +------------+ +------+------+ | User +----------&gt;+ FastHTTP +------&gt;+ Router +------&gt;+ Controller +-----&gt;+ API/View | +------+ +----------+ +--------+ +-----+------+ +-------------+ | | +----------+ +-----+------+ | Database +-----&gt;+ GORM / RDM | +----------+ +------------+ . ",
    "url": "http://localhost:4000/docs/why-evo/",
    "relUrl": "/docs/why-evo/"
  }
}
